% \chapter{Technical Fundamentals}
% Since the main part of this thesis addresses the implementation of flow control algorithms for a left ventricular assist device, the basics of control theory and a introduction on iterative learning control will be presented here as well.

\chapter{Control Theory}
Since the field of control theory is a very extensive one, this section will only deal with the fundamentals of notation and structure of a standard control loop. Furthermore, the basic principles of PI-controllers and  iterative learning control (ILC) are discussed, since these are used within the pratical part of the thesis.
\section{Fundamentals}
The basic task of control engineering is to influence a time-varying process from the outside with the goal that the process is executed in a predetermined manner. A control system is characterized in particular by the feedback of the controlled variable to the reference variable. The reference variable represents the state to be achieved.
In theory, this is represented by a control loop with the components shown in \figurename~{\ref{fig:control_loop}}.
\begin{figure}
  \centering
  \includegraphics[width=0.9\textwidth]{images/control_loop.jpg}
  \caption[General structure of a control loop]{General structure of a control loop}
  \label{fig:control_loop}
\end{figure}
The plant $G(s)$ transfers the actuating variable $u(t)$, as well as the influence of the the disturbance $d(t)$, to the controlled variable $y(t)$. This variable is permanently compared with the reference variable $w(t)$ by means of a feedback. This feedback provides the control error
\begin{equation}
  e(t) = w(t) - y(t).
 \label{eq:e_t}
\end{equation}
The controller $G_{c}(s)$ then transfers the control error to the actuating variable again. The aim of the control loop is to achieve the smallest possible control error with the highest possible damping. Since these goals contradict each other, a trade off must always be accepted here.\cite{Reg_17}
\\However, there are some general requirements for the closed control loop, which have to be fulfilled. The first of which states that the closed loop needs to be stable. This requirement is met if the control loop responds to a finite excitation with a finite output signal. The second condition is the requirement for disturbance rejection, stating that the controlled variable needs to follow the reference variable asymptotically, so that
\begin{equation}
    \lim\limits_{t \rightarrow \infty}{e(t)} = 0.
 \label{eq:lim_e}
\end{equation}
Another requirement is that the dynamic relationship between the reference variable $w(t)$ and the controlled variable $y(t)$ must satisfy specified quality requirements.  The last requirement states that the first three requirements must be satisfied despite uncertainties in the plant. This requirement is called the robustness requirement. More detailed information on these requirements can be found in \cite{Reg_10}.

The plant $G(s)$ corresponds to the part of the system in which the physical quantity to be controlled is influenced by the controller. The calculation of the plant, by setting up and solving differential equations, is possible only in a few cases. Due to this, the determination of the plant's characteristic values is usually carried out experimentally. There are several basic types of plants. These are classified according to their dynamic behavior. As only the PT$_{1}$-element is used in the practical part of this thesis, all other variations will not be discussed at this point. Detailed information on this topic can, once more, be found in \cite{Reg_10}.
\\The PT$_{1}$-element is the plant type which is most common in technical equipment. A PT$_{n}$-element, in it's static state, reacts proportionally to the input value and has a distinct transition behavior. The index n describes the system order. A PT$_{1}$-element therefore is a proportional delay element of first order. The mathematical formulation of the transfer function of a PT$_{1}$-element is
\begin{equation}
    G(s) = \frac{k_{s}}{1+sT}.
 \label{eq:tf_pt1}
\end{equation}

\begin{figure}[h]
   \centering
   \includegraphics[width=0.9\textwidth]{images/tf_pt1.jpg}
   \caption[Tranfer function of a PT$_{1}$-element]{Transfer function of a PT$_{1}$-element \cite{Reg_10}.}
   \label{fig:tf_pt1}
 \end{figure}
The value $k_{s}$ describes the static gain, which equals the final value of the transfer function. The time constant T enables an impression of the speed with which the system can react to changes at the input. It is defined as the time at which the transfer function reaches 63\% of it's static gain. \cite{Reg_10}
\figurename~\ref{fig:tf_pt1} shows the tranfer function of a PT$_{1}$-element and it's significant parameters.


\section{PI-controller}
A PI-controller is a control structure commonly used for linear systems. This structure consists of both a propotional and an integral control element.
The output value of a P-controller is proportional to it's input value. In relation to the control loop in \figurename~\ref{fig:control_loop} this leads to
\begin{equation}
    u(t) = K_{P}e(t).
 \label{eq:p_contr_1}
\end{equation}
Using Laplacetransformation the transfer function for a P-controller can be determined as
\begin{equation}
    G(s) = \frac{u(s)}{e(s)} = K_{P}
 \label{eq:p_contr_2}
\end{equation}
Therefore, the step response of this controller equals a step weighted with the Parameter $K_{P}$.
The relationship between input and output value of an I-controller is described through
\begin{equation}
    u(t) = K_{I}\int e(t) dt.
 \label{eq:i_contr_1}
\end{equation}
Just as with the P-controller, Laplacetransformation can be used to determine the transfer function of the I-controller.
This leads to
\begin{equation}
    G(s) = \frac{u(s)}{e(s)} = \frac{K_{I}}{s},
 \label{eq:i_contr_2}
\end{equation}
which indicates a step response in form of a ramp with slope $K_{I}$.
In order to generate a PI-controller these elements can be added, which leads to
\begin{equation}
    u(t) = K_{P}e(t) + K_{I}\int e(t) dt.
 \label{eq:pi_contr_1}
\end{equation}
The Laplacetransformation can be used again to formulate the transfer function
\begin{equation}
    G(s) = \frac{u(s)}{e(s)} =  K_{P} + \frac{K_{I}}{s}.
 \label{eq:pi_contr_2}
\end{equation}
The step response of the PI-controller, illustrated in \figurename~\ref{fig:step_resp_pi}, shows both the weigthed step from the P-controller and the ramp from the I-controller.

\begin{figure}[h]
   \centering
   \includegraphics[width=0.4\textwidth]{images/step_resp_pi.jpg}
   \caption[Step response of a PI-Controller]{Step response of a PI-Controller}
   \label{fig:step_resp_pi}
 \end{figure}

\subsection{Tuning rules}
In regards to the controller parameters, tuning is of great importance. If the parameters are chosen incorrectly it can lead to unstable system behavior, which may result in system damage. There are many different approaches to tuning a PI-Controller in order to achieve the best system performance. These are reaching from heuristic methods, over analysis of pole-zero plots, to computer-aided numerical parameter optimization. \cite{Reg_10} At this point only the tuning rules according to Ziegler Nichols (ZN) and the rules according to Chien Hrones Reswick (CHR) will be discussed, as these have been used for the implementation of flow control in the practical work.  Information on other approaches can be found in \cite{Reg_11}.

\subsubsection{Tuning rules according to Ziegler Nichols}
The tuning rules according to Ziegler Nichols are one of the most commoly used heuristic methods in tuning controller parameters for PID-controllers. They are used especially, if a mathematical model of the plant is not available, but the plant can be approximated as a PT$_{n}$-element. \cite{Reg_17}
A necessary condition for this is that the step response of the plant needs to be experimentally identifiable without risk of damage to the system. After the step response has been determined it is displayed graphically. Then the inflection tangent is drawn into the step response as shown in \figurename~\ref{fig:param_zn}.
\begin{figure}
   \centering
   \includegraphics[width=0.7\textwidth]{images/param_zn.jpg}
   \caption[Inflection tangent method Ziegler Nichols]{Inflection tangent method Ziegler Nichols}
   \label{fig:param_zn}
 \end{figure}
The gain $K_{P}$, the delay time $T_{v}$ and the settling time $T_{g}$ can be read from the graph.
The calculation of the controller parameters is performed according to the data in \tablename~\ref{tab:param_zn}. The factor $K_{p}$ from the table equals the term $K_{p}$ in (\ref{eq:pi_contr_2}), while the factor $K_{I}$ is calculated according to:
\begin{equation}
    K_{I}  = \frac{K_{P}}{T_{N}}.
 \label{eq:K_I}
\end{equation}
\begin{table}
  \centering
  \begin{tabularx}{0.6\textwidth}{c|c|c|c}
    \toprule
    Controller type & $K_{P}$ &  $T_{N}$ & $T_{D}$   \\
    \midrule
    P-Controller &  $\frac{T_{g}}{K_{S}T_{v}}$ & - & - \\
    & & & \\
    PI-Controller & $0.9\frac{T_{g}}{K_{S}T_{v}}$ & $3.33T_{v}$ & - \\
    & & & \\
    PID-Controller & $0.9\frac{T_{g}}{K_{S}T_{v}}$ & $2T_{v}$ & $0.5T_{v}$ \\
     \bottomrule
  \end{tabularx}
  \caption[Tuning parameters Ziegler Nichols]{Tuning parameters according to Ziegler Nichols}
  \label{tab:param_zn}
\end{table}

\subsubsection{Tuning rules according to Chien Hrones Reswick}
The tuning method according to Chien Hrones Reswick is a very similar one to the one by Ziegler Nichols. However, this method provides the ability to adjust the transient response of the control loop. The tuning parameters can either be chosen in a way to provide an over damped behavior or a course providing 20\% overshoot. \cite{Reg_11}
For both options the step response and its inflection tangent is graphically displayed, as for the Ziegler Nichols approach in \figurename~\ref{fig:param_zn}.
The values for $K_{P}$, $T_{v}$ and $T_{g}$ are read from the plot. The parameter value $K_{I}$ again is calculated following (\ref{eq:K_I}). \tablename~\ref{tab:param_chr} gives the formulas for calculation of $K_{P}$,  $T_{N}$ and $T_{D}$.

\begin{table}
  \centering
  \begin{tabular}{c|ccc|ccc}
    \toprule
     & \multicolumn{3}{c|}{over damped} & \multicolumn{3}{c}{20\% overshoot} \\
    \midrule
    Controller type & $K_{P}$ &  $T_{N}$ & $T_{D}$ & $K_{P}$ &  $T_{N}$ & $T_{D}$ \\
    \midrule
    P-Controller & $0.3\frac{T_{g}}{K_{S}T_{v}}$ & - & - & $0.7\frac{T_{g}}{K_{S}T_{v}}$ & - & - \\
    & & & & & & \\
    PI-Controller & $0.35\frac{T_{g}}{K_{S}T_{v}}$ & $1.2T_{v}$ & - & $0.6\frac{T_{g}}{K_{S}T_{v}}$ & $T_{v}$ & - \\
        & & & & & & \\
    PID-Controller & $0.6\frac{T_{g}}{K_{S}T_{v}}$ & $T_{v}$ & $0.5T_{v}$ & $0.95\frac{T_{g}}{K_{S}T_{v}}$ & $1.35T_{v}$ & $0.47T_{v}$\\
    \bottomrule
\end{tabular}
  \caption[Tuning parameters Chien Hrones Reswick]{Tuning parameters according to Chien Hrones Reswick}
  \label{tab:param_chr}
\end{table}

\section{Iterative Learning Control}
The use of iterative learning control aims to improve control performance for systems which execute the same task repeatedly under constant operation conditions. This improvement is based on the idea that it is possible to include error information from previous iterations into the adjustment of the actuation variable during the current iteration.
The standard control structure of an ILC algorithm is presented in \figurename~\ref{fig:ILC_only}.
\begin{figure}[h]
   \centering
   \includegraphics[width=0.9\textwidth]{images/ILC_only.jpg}
   \caption[Standard ILC control loop]{Standard ILC control loop}
   \label{fig:ILC_only}
 \end{figure}
Considering a linear-time-invariant single-input-single-output system, the ILC learning algorithm would be as follows:
\begin{equation}
    u_{j+1}  = Q(q)[u_{j}(k)+L(q)e_{j}(k+1)]
 \label{eq:ILC_standard}
\end{equation}
where $k$ is the time index, $j$ is the iteration index, $Q(q)$ is defined as the Q-Filter and $L(q)$ represents the learning function. The performance error signal $e_{j}$ is defined as
\begin{equation}
    e_{j}  = w_{j}-y_{j}.
 \label{eq:perf_error}
\end{equation}

 Feedback controllers, such as PI-controllers, are only able to include the current changes in control error. By taking into account the information from previous iterations low tracking errors are achievable through an ILC. This results in very high performance, with convergence during the first few iterations. This can be achieved even for systems prone to repeating disturbances and model uncertainties. While feedback control has a lag in transient tracking, due to reacting to inputs and disturbances, ILC, as a feedforward controller, does not. Another advantage of ILC use is that there is no need for disturbances to be known or measured, as long as these signals show repeating behavior during each iteration. Furthermore, through storing signal information during each iteration ILC enables advanced filtering and signal processing of the control error. However, ILC utilization holds some issues in regards to non-repeating disturbances or noise influences. In these cases it may be useful to combine ILC approaches with a feeback controller. A combination of the systems is also recommended if the plant's behavior is not stable. \cite{ILC2} A parallel architecture of a feedback controller in combination with an ILC is illustrated in \figurename~\ref{fig:ILC_parallel}.
 \begin{figure}[h]
    \centering
    \includegraphics[width=0.9\textwidth]{images/ILC_parallel.jpg}
    \caption[Parallel architecture of ILC with feedback controller]{Parallel architecture of ILC with feedback controller}
    \label{fig:ILC_parallel}
  \end{figure}
\\There are different approaches to designing an ILC. In general, an ILC ideally only learns the repeating disturbance patterns without being influenced by noise. The most common types of ILC learning functions are the P-, D- and PD-type learning functions. As an ILC does have an natural integrator action from one iteration to the next, I-type learning functions are not used that frequently.
\\The discrete-time learning function for a standard PD-type ILC is given as either
\begin{equation}
    u_{j+1}(k) = u_{j}(k)+k_{p}e_{j}(k+1)+k_{d}[e_{j}(k+1)-e_{j}(k)]
 \label{eq:PD_type}
 \end{equation}
 or
 \begin{equation}
     u_{j+1}(k) = u_{j}(k)+k_{p}e_{j}(k)+k_{d}[e_{j}(k+1)-e_{j}(k)].
  \label{eq:PD_type_2}
  \end{equation}
$k_{p}$ represents the proportional gain, while $k_{d}$ is the derivative gain. In case a P-type learning function is implemented the derivation gain is set to $k_{d}=0$. For a D-type learning function $k_{p}=0$ is used, respectively.
\\The performance of these ILC types depends mainly on accurate parameter tuning and does not require an acurate mathematical model of the plant. Despite these approaches being frequently used, there are no tuning guidelines similar to the once mentioned for PI-controller tuning. However, a commonly used way to influence the process behavior is to modify the learning algorithm to include a Q-Filter. This filter can be used to disable learning at high frequiencies, in order to filter high-frequency noise. It furthermore increases robustness. First a filter type, such as Butterworth or Chebyshev, is specified. The bandwith can then be interpreted as a tuning parameter, in addition to the proportional gain $k_{p}$. Initially learning gain and filter bandwidth are set to low values. When a steady baseline behavior and error performance is achieved, the parameter values can be increased to improve performance. The learning gain influences the rate of error convergence, while the Q-Filter influences the error performance. The higher the filter bandwidth, the more increased is the performance. However, this includes a trade-off in robustness. For lower filter bandwidth high robustness can be achieved in a trade-off in performance.
\\Besides the P-,D- and PD-type ILC there are other design approaches. The $H_{\infty}$ method can be used to design a robustly convergent ILC controller, with a trade-off in performance. A quickly converging ILC approach can be achieved by using the plant inversion method. This however depends greatly on an accurate modeling of the plant. The quadratically optimal ILC approach uses quadratic performance criteria to design an optimal ILC. Further information on these alternative design methods is provided in \cite{ILC2}.
